package Programa;
import TDAMapeo.*;
import Exceptions.*;
import TDAPila.*;
import TDACola.*;
import TDALista.*;
import Auxiliar.*;

public class CuentaBancaria {

	//Tributes
	protected String accessCode, firstName, lastName;
	protected int docNumber;
	protected float initialAmount, amount;
	protected PositionList <Transaccion> transactionsHistory;
	
	//Constructors
	public CuentaBancaria(String firstName, String lastName, String accessCode, int docNumber, float initialAmount) {
		this.firstName= firstName;
		this.lastName= lastName;
		try {
		if(checkCode(accessCode))
			this.accessCode= accessCode;
		}catch(InvalidAccessCodeException e) {e.printStackTrace();}
		this.docNumber= docNumber;
		this.initialAmount= initialAmount;
		this.amount+= this.initialAmount;
		transactionsHistory= new DoubleLinkedList<Transaccion>();
	}
	public CuentaBancaria(String firstName, String lastName, String accessCode, int docNumber) {
		this(firstName, lastName, accessCode, docNumber, 0);
		amount+= initialAmount;
	}
	
	//Methods
	public boolean checkCode(String code) throws InvalidAccessCodeException{
		boolean aux= true;
		Stack<Character> stack1= new PilaConEnlaces<Character>();
		Stack<Character> stack2= new PilaConEnlaces<Character>();
		Queue<Character> queue= new ColaConArregloCircular<Character>();
		
		for(int i=0; i<lastName.length(); i++) {
			queue.enqueue(lastName.charAt(i));
			stack1.push(lastName.charAt(i));
			stack2.push(lastName.charAt(i));
		}
		queue.enqueue('x');
		
		try {
			while(!stack1.isEmpty())
				queue.enqueue(stack1.pop());
			while(!stack2.isEmpty())
				queue.enqueue(stack2.pop());
		
			for(int i=0; i<code.length() && aux; i++) {
				if(queue.dequeue()!=code.charAt(i)) 
					throw new InvalidAccessCodeException("ERROR: La clave de acceso es incorrecta.");
			}
		}catch(EmptyStackException | EmptyQueueException e) {
			e.printStackTrace();
		}
		return aux;
	}
	
	public void transferences(String firstName, String lastName, int docNumber, String payType, float amountTransference) throws InsuficientAmountException {
		if(amount>=amountTransference) {
			amount-=amountTransference;
			Transaccion transference= new Transaccion(firstName, lastName, docNumber,"Débito", amountTransference);
			transactionsHistory.addLast(transference);
		}
		else throw new InsuficientAmountException("ERROR: Saldo insuficiente.");
	}
	public void deposites(String firstName, String lastName, int docNumber, String payType, float amountDeposite) {
		amount+= amountDeposite;
		Transaccion transference= new Transaccion(firstName, lastName, docNumber, "Crédito", amountDeposite);
		transactionsHistory.addLast(transference);
	}
	public PositionList<Transaccion> nTrans(int n) {
		PositionList<Transaccion> list= new DoubleLinkedList<Transaccion>();
		try {
			Position<Transaccion> pos= transactionsHistory.last();
			for(int i=0; i<n; i++) {
				list.addLast(pos.element());
				pos= transactionsHistory.prev(pos);
			}
		}catch(EmptyListException | BoundaryViolationException | InvalidPositionException e){e.printStackTrace();}
		return list;
	}
	
	public PositionList<Transaccion> operacionMismoValor(int valor) {
		Dictionary<Float, Transaccion> d = new DiccionarioHashAbierto<Float, Transaccion>();
		PositionList<Transaccion> list = new DoubleLinkedList<Transaccion>();
		try {
			for(Transaccion t : transactionsHistory) {
				d.insert(t.getAmount(), t)
			}
			if(d.find(valor).getKey() != null) {
				for(Entry<Float, Transaccion> j : d.findAll(valor)){
					
						list.addLast(j.getValue());
				}
			}
		}catch(InvalidKeyException e) {
			e.printStackTrace();
		}
		return list;
	}
	
}